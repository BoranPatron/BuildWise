#!/usr/bin/env python3
"""
Test Frontend Fee Integration
============================

Testet die Frontend-Integration der korrigierten BuildWise-Geb√ºhren.
Stellt sicher, dass die Dienstleisteransicht korrekte Geb√ºhren anzeigt.
"""

import asyncio
import os
import sys
import requests
from datetime import datetime

# F√ºge das Projektverzeichnis zum Python-Pfad hinzu
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from app.core.config import settings
from app.core.database import get_db
from app.models.buildwise_fee import BuildWiseFee
from app.models.quote import Quote


class FrontendFeeIntegrationTester:
    """Testet die Frontend-Integration der Geb√ºhren."""
    
    def __init__(self):
        self.api_base_url = "http://localhost:8000"
        self.test_results = []
    
    async def test_backend_api(self):
        """Testet die Backend-API f√ºr Geb√ºhren."""
        print("üß™ Teste Backend-API...")
        
        try:
            # Test 1: Environment-Info API
            response = requests.get(f"{self.api_base_url}/api/v1/environment/info")
            if response.status_code == 200:
                env_info = response.json()
                print(f"‚úÖ Environment-Info API:")
                print(f"   - Modus: {env_info['environment_mode']}")
                print(f"   - Geb√ºhren: {env_info['fee_percentage']}%")
                
                self.test_results.append({
                    'test': 'Environment-Info API',
                    'status': 'PASS',
                    'details': f"Modus: {env_info['environment_mode']}, Geb√ºhren: {env_info['fee_percentage']}%"
                })
            else:
                print(f"‚ùå Environment-Info API fehlgeschlagen: {response.status_code}")
                self.test_results.append({
                    'test': 'Environment-Info API',
                    'status': 'FAIL',
                    'details': f"Status: {response.status_code}"
                })
            
            # Test 2: BuildWise-Fees API
            response = requests.get(f"{self.api_base_url}/api/v1/buildwise-fees/")
            if response.status_code == 200:
                fees = response.json()
                print(f"‚úÖ BuildWise-Fees API:")
                print(f"   - Anzahl Geb√ºhren: {len(fees)}")
                
                if fees:
                    # Analysiere Geb√ºhren-Prozents√§tze
                    percentages = {}
                    for fee in fees:
                        percentage = fee.get('fee_percentage', 0)
                        if percentage not in percentages:
                            percentages[percentage] = 0
                        percentages[percentage] += 1
                    
                    print(f"   - Geb√ºhren-Verteilung:")
                    for percentage, count in sorted(percentages.items()):
                        expected = settings.get_current_fee_percentage()
                        status = "‚úÖ KORREKT" if percentage == expected else "‚ùå FALSCH"
                        print(f"     {percentage}%: {count} Geb√ºhren {status}")
                
                self.test_results.append({
                    'test': 'BuildWise-Fees API',
                    'status': 'PASS',
                    'details': f"Anzahl: {len(fees)}"
                })
            else:
                print(f"‚ùå BuildWise-Fees API fehlgeschlagen: {response.status_code}")
                self.test_results.append({
                    'test': 'BuildWise-Fees API',
                    'status': 'FAIL',
                    'details': f"Status: {response.status_code}"
                })
                
        except Exception as e:
            print(f"‚ùå Backend-API Test fehlgeschlagen: {e}")
            self.test_results.append({
                'test': 'Backend-API',
                'status': 'ERROR',
                'details': str(e)
            })
    
    async def test_database_consistency(self):
        """Testet die Datenbank-Konsistenz der Geb√ºhren."""
        print("\nüß™ Teste Datenbank-Konsistenz...")
        
        try:
            async for db in get_db():
                try:
                    # Hole alle Geb√ºhren
                    from sqlalchemy import select
                    query = select(BuildWiseFee)
                    result = await db.execute(query)
                    fees = result.scalars().all()
                    
                    if not fees:
                        print("‚ÑπÔ∏è  Keine Geb√ºhren in der Datenbank gefunden")
                        self.test_results.append({
                            'test': 'Database Consistency',
                            'status': 'INFO',
                            'details': 'Keine Geb√ºhren vorhanden'
                        })
                        return
                    
                    print(f"üìä Gefundene Geb√ºhren: {len(fees)}")
                    
                    # Analysiere Konsistenz
                    expected_percentage = settings.get_current_fee_percentage()
                    correct_count = 0
                    incorrect_count = 0
                    
                    for fee in fees:
                        actual_percentage = float(fee.fee_percentage)
                        if actual_percentage == expected_percentage:
                            correct_count += 1
                        else:
                            incorrect_count += 1
                            print(f"   ‚ùå Geb√ºhr ID {fee.id}: {actual_percentage}% statt {expected_percentage}%")
                    
                    print(f"‚úÖ Korrekte Geb√ºhren: {correct_count}")
                    print(f"‚ùå Falsche Geb√ºhren: {incorrect_count}")
                    
                    if incorrect_count == 0:
                        self.test_results.append({
                            'test': 'Database Consistency',
                            'status': 'PASS',
                            'details': f"Alle {correct_count} Geb√ºhren korrekt"
                        })
                    else:
                        self.test_results.append({
                            'test': 'Database Consistency',
                            'status': 'FAIL',
                            'details': f"{correct_count} korrekt, {incorrect_count} falsch"
                        })
                        
                finally:
                    await db.close()
                    
        except Exception as e:
            print(f"‚ùå Datenbank-Test fehlgeschlagen: {e}")
            self.test_results.append({
                'test': 'Database Consistency',
                'status': 'ERROR',
                'details': str(e)
            })
    
    async def test_environment_configuration(self):
        """Testet die Environment-Konfiguration."""
        print("\nüß™ Teste Environment-Konfiguration...")
        
        current_mode = settings.environment_mode.value
        current_fee_percentage = settings.get_current_fee_percentage()
        
        print(f"üéØ Aktuelle Konfiguration:")
        print(f"   - Modus: {current_mode}")
        print(f"   - Geb√ºhren: {current_fee_percentage}%")
        print(f"   - Ist Beta: {settings.is_beta_mode()}")
        print(f"   - Ist Production: {settings.is_production_mode()}")
        
        # Validiere Konfiguration
        if current_mode == "beta" and current_fee_percentage == 0.0:
            status = "PASS"
            details = "Beta-Modus korrekt konfiguriert (0.0%)"
        elif current_mode == "production" and current_fee_percentage == 4.7:
            status = "PASS"
            details = "Production-Modus korrekt konfiguriert (4.7%)"
        else:
            status = "FAIL"
            details = f"Falsche Konfiguration: {current_mode} mit {current_fee_percentage}%"
        
        print(f"   - Status: {status}")
        
        self.test_results.append({
            'test': 'Environment Configuration',
            'status': status,
            'details': details
        })
    
    async def test_fee_calculation(self):
        """Testet die Geb√ºhren-Berechnung."""
        print("\nüß™ Teste Geb√ºhren-Berechnung...")
        
        try:
            async for db in get_db():
                try:
                    # Hole ein Beispiel-Angebot
                    from sqlalchemy import select
                    query = select(Quote).limit(1)
                    result = await db.execute(query)
                    quote = result.scalar_one_or_none()
                    
                    if not quote:
                        print("‚ùå Kein Angebot f√ºr Test gefunden")
                        self.test_results.append({
                            'test': 'Fee Calculation',
                            'status': 'SKIP',
                            'details': 'Kein Angebot verf√ºgbar'
                        })
                        return
                    
                    quote_amount = float(quote.total_amount)
                    expected_fee_percentage = settings.get_current_fee_percentage()
                    expected_fee_amount = quote_amount * (expected_fee_percentage / 100.0)
                    
                    print(f"üìã Test mit Angebot ID {quote.id}:")
                    print(f"   - Angebotsbetrag: {quote_amount}‚Ç¨")
                    print(f"   - Erwarteter Prozentsatz: {expected_fee_percentage}%")
                    print(f"   - Erwartete Geb√ºhr: {expected_fee_amount}‚Ç¨")
                    
                    # Teste Service-Methode
                    from app.services.buildwise_fee_service import BuildWiseFeeService
                    
                    # Pr√ºfe ob bereits eine Geb√ºhr existiert
                    existing_fee_query = select(BuildWiseFee).where(BuildWiseFee.quote_id == quote.id)
                    existing_fee_result = await db.execute(existing_fee_query)
                    existing_fee = existing_fee_result.scalar_one_or_none()
                    
                    if existing_fee:
                        actual_percentage = float(existing_fee.fee_percentage)
                        actual_amount = float(existing_fee.fee_amount)
                        
                        print(f"   - Existierende Geb√ºhr: {actual_percentage}% = {actual_amount}‚Ç¨")
                        
                        if actual_percentage == expected_fee_percentage:
                            print("   ‚úÖ Geb√ºhren-Berechnung korrekt")
                            self.test_results.append({
                                'test': 'Fee Calculation',
                                'status': 'PASS',
                                'details': f"Korrekt: {actual_percentage}% = {actual_amount}‚Ç¨"
                            })
                        else:
                            print("   ‚ùå Geb√ºhren-Berechnung falsch")
                            self.test_results.append({
                                'test': 'Fee Calculation',
                                'status': 'FAIL',
                                'details': f"Falsch: {actual_percentage}% statt {expected_fee_percentage}%"
                            })
                    else:
                        print("   - Keine existierende Geb√ºhr gefunden")
                        self.test_results.append({
                            'test': 'Fee Calculation',
                            'status': 'INFO',
                            'details': 'Keine existierende Geb√ºhr'
                        })
                        
                finally:
                    await db.close()
                    
        except Exception as e:
            print(f"‚ùå Geb√ºhren-Berechnung Test fehlgeschlagen: {e}")
            self.test_results.append({
                'test': 'Fee Calculation',
                'status': 'ERROR',
                'details': str(e)
            })
    
    def print_summary(self):
        """Zeigt eine Zusammenfassung der Test-Ergebnisse."""
        print("\n" + "=" * 60)
        print("üìä Frontend Fee Integration Test - Zusammenfassung")
        print("=" * 60)
        
        passed = sum(1 for result in self.test_results if result['status'] == 'PASS')
        failed = sum(1 for result in self.test_results if result['status'] == 'FAIL')
        errors = sum(1 for result in self.test_results if result['status'] == 'ERROR')
        skipped = sum(1 for result in self.test_results if result['status'] in ['SKIP', 'INFO'])
        
        print(f"‚úÖ Bestanden: {passed}")
        print(f"‚ùå Fehlgeschlagen: {failed}")
        print(f"‚ö†Ô∏è  Fehler: {errors}")
        print(f"‚ÑπÔ∏è  √úbersprungen: {skipped}")
        
        print("\nüìã Detaillierte Ergebnisse:")
        for result in self.test_results:
            status_icon = "‚úÖ" if result['status'] == 'PASS' else "‚ùå" if result['status'] == 'FAIL' else "‚ö†Ô∏è" if result['status'] == 'ERROR' else "‚ÑπÔ∏è"
            print(f"   {status_icon} {result['test']}: {result['details']}")
        
        if failed == 0 and errors == 0:
            print("\nüéâ Alle Tests erfolgreich! Frontend-Integration funktioniert korrekt.")
        else:
            print(f"\n‚ö†Ô∏è  {failed + errors} Tests fehlgeschlagen. Bitte Probleme beheben.")


async def main():
    """Hauptfunktion f√ºr Frontend-Integration-Tests."""
    print("üèóÔ∏è  Frontend Fee Integration Tester")
    print("=" * 60)
    
    tester = FrontendFeeIntegrationTester()
    
    try:
        await tester.test_environment_configuration()
        await tester.test_database_consistency()
        await tester.test_backend_api()
        await tester.test_fee_calculation()
        
        tester.print_summary()
        
    except Exception as e:
        print(f"‚ùå Test fehlgeschlagen: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    asyncio.run(main()) 